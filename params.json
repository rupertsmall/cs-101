{"name":"CS-101","tagline":"Coding, Part Zero","body":"### CS-101\r\nThe basics of coding involve learning to do the simple things in life. From scratch. When learning to code it's therefore not just important to know which library command takes the square root of a number, or which method appends an item onto the end of a list. No, you must learn how to do those things _with your bare hands_. Welcome to Level 0.\r\n\r\n### Square Roots\r\nImagine you are a computer living peacefully in Computer Land and imagine that your skills are extremely limited: for loops, while loops, multiplication, division (etc) you can do no problem. But in the Computer Land you are in you have no predefined functions or libraries. How do you find the square root of a number? You use a root finding algorithm such as the [Newton-Rhapson method](http://mathworld.wolfram.com/NewtonsMethod.html)\r\n\r\nIn [sqrt.py](https://github.com/rupertsmall/cs-101/blob/master/sqrt.py) the job is firstly to find the order of magnitude of the answer to seed your guess\r\n```\r\n# order of magnitude for seed guess\r\n p = float(argv[1])\r\n remainder = p\r\n orderOfMagnitude = 1\r\n while remainder >= 10:\r\n          remainder = remainder/10\r\n          orderOfMagnitude += 1\r\n\r\n orderOfMagnitude /= 2\r\n guess = 10**orderOfMagnitude\r\n```\r\nand then implement the root finding algorithm\r\n```\r\n# calculate sqrt() \r\n while error > epsilon:\r\n          guess = .5*guess + .5*p/guess\r\n          error = abs(p-guess**2)\r\n```\r\n### _Any_ Root\r\nUsing the same idea's as for the square root it is possible to use a root finding algorithm to find the _n_'th root of a number ([nroot.py](https://github.com/rupertsmall/cs-101/blob/master/nroot.py)) now with _n_ being anything, even a negative [real number](https://en.wikipedia.org/?title=Real_number)! This time the seeding of the guess is slightly different:\r\n```\r\norderOfMagnitude = 1\r\n while remainder >= 10:\r\n          remainder = remainder/10\r\n          orderOfMagnitude += 1\r\n\r\n orderOfMagnitude /= n\r\n guess = 10**orderOfMagnitude\r\n```\r\nand the iterative process for finding better and better approximations must be changed to:\r\n```\r\n# calculate n'th root \r\n while error > epsilon:\r\n          guess = ((n-1)/n)*guess + (p/n)/guess**(n-1)\r\n          error = abs(p-guess**n)\r\n```\r\n### Factorial\r\nA classic question for introducing [recursion](https://en.wikipedia.org/wiki/Recursion_%28computer_science%29) is how to calculate the factorial of _n_? It's an interesting question because the answer can be expressed recursively ([factorial.py](https://github.com/rupertsmall/cs-101/blob/master/factorial.py)). On the other hand you don't have to express it recursively if you really don't want to. The recursive solution looks like this:\r\n```\r\ndef factorial(n):\r\n        if n==1:\r\n                return n\r\n        else:\r\n                return n*factorial(n-1)\r\n```\r\n### Sin() and Cos()\r\nIf you're itching to write a function called sin.py or if you really want to figure out a way for a computer with no special functions or libraries to calculate sin(_number_) then you will want to look into the [Taylor Series](http://mathworld.wolfram.com/TaylorSeries.html) of the sin() function. For sin( ) you're going to have something like\r\n```\r\nsinX = X - X**3/6 + X**5/120 - X**7/5040 + X**9/362880 - X**11/39916800\r\n```\r\nwith a trick or two to make sure that _X_ is close as possible to zero:\r\n```\r\nX %= 2*pi\r\n if X > pi:\r\n        X = -X + pi\r\n elif X < -pi:\r\n        X = -X - pi\r\n```\r\nNote that the further _X_ is from zero, the worse the approximation. Can you think of a way to alter the code to allow _X_ to be even closer to zero ?\r\n\r\nFor calculating cos(_X_) without using library functions ([cos.py](https://github.com/rupertsmall/cs-101/blob/master/cos.py)) you can use the same Taylor expansion method used for sin(_X_):\r\n```\r\ncosX = 1 - X**2/2 + X**4/24 - X**6/720 + X**8/40320 - X**10/3628800\r\n```\r\nand again you should find a way to make sure _X_ is as close to zero as possible:\r\n```\r\nX = abs(float(save))           # take abs() because cos(X) = cos(-X)\r\nX %= 2*pi\r\nif X > pi:                     # in this case cos(X) = cos(2pi - X)\r\n        X = 2*pi - X\r\n```\r\nCan you improve on the accuracy of the approximations by altering the code to bound _X_ by an even smaller number?\r\n\r\n(TBC. Work In Progress)","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}