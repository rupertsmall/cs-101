<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>CS-101 by rupertsmall</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">CS-101</h1>
      <h2 class="project-tagline">Coding, Part Zero</h2>
      <a href="https://github.com/rupertsmall/cs-101" class="btn">View on GitHub</a>
      <a href="https://github.com/rupertsmall/cs-101/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/rupertsmall/cs-101/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h3>
<a id="cs-101" class="anchor" href="#cs-101" aria-hidden="true"><span class="octicon octicon-link"></span></a>CS-101</h3>

<p>The basics of coding involve learning to do the simple things in life. From scratch. When learning to code it's therefore not just important to know which library command takes the square root of a number, or which method appends an item onto the end of a list. No, you must learn how to do those things <em>with your bare hands</em>. Welcome to Level 0.</p>

<h3>
<a id="square-roots" class="anchor" href="#square-roots" aria-hidden="true"><span class="octicon octicon-link"></span></a>Square Roots</h3>

<p>Imagine you are a computer living peacefully in Computer Land and imagine that your skills are extremely limited: for loops, while loops, multiplication, division (etc) you can do no problem. But in the Computer Land you are in you have no predefined functions or libraries. How do you find the square root of a number? You use a root finding algorithm such as the <a href="http://mathworld.wolfram.com/NewtonsMethod.html">Newton-Rhapson method</a></p>

<p>In <a href="https://github.com/rupertsmall/cs-101/blob/master/sqrt.py">sqrt.py</a> the job is firstly to find the order of magnitude of the answer to seed your guess</p>

<pre><code># order of magnitude for seed guess
 p = float(argv[1])
 remainder = p
 orderOfMagnitude = 1
 while remainder &gt;= 10:
          remainder = remainder/10
          orderOfMagnitude += 1

 orderOfMagnitude /= 2
 guess = 10**orderOfMagnitude
</code></pre>

<p>and then implement the root finding algorithm</p>

<pre><code># calculate sqrt() 
 while error &gt; epsilon:
          guess = .5*guess + .5*p/guess
          error = abs(p-guess**2)
</code></pre>

<h3>
<a id="any-root" class="anchor" href="#any-root" aria-hidden="true"><span class="octicon octicon-link"></span></a>
<em>Any</em> Root</h3>

<p>Using the same idea's as for the square root it is possible to use a root finding algorithm to find the <em>n</em>'th root of a number (<a href="https://github.com/rupertsmall/cs-101/blob/master/nroot.py">nroot.py</a>) now with <em>n</em> being anything, even a negative <a href="https://en.wikipedia.org/?title=Real_number">real number</a>! This time the seeding of the guess is slightly different:</p>

<pre><code>orderOfMagnitude = 1
 while remainder &gt;= 10:
          remainder = remainder/10
          orderOfMagnitude += 1

 orderOfMagnitude /= n
 guess = 10**orderOfMagnitude
</code></pre>

<p>and the iterative process for finding better and better approximations must be changed to:</p>

<pre><code># calculate n'th root 
 while error &gt; epsilon:
          guess = ((n-1)/n)*guess + (p/n)/guess**(n-1)
          error = abs(p-guess**n)
</code></pre>

<h3>
<a id="factorial" class="anchor" href="#factorial" aria-hidden="true"><span class="octicon octicon-link"></span></a>Factorial</h3>

<p>A classic question for introducing <a href="https://en.wikipedia.org/wiki/Recursion_%28computer_science%29">recursion</a> is how to calculate the factorial of <em>n</em>? It's an interesting question because the answer can be expressed recursively (<a href="https://github.com/rupertsmall/cs-101/blob/master/factorial.py">factorial.py</a>). On the other hand you don't have to express it recursively if you really don't want to. The recursive solution looks like this:</p>

<pre><code>def factorial(n):
        if n==1:
                return n
        else:
                return n*factorial(n-1)
</code></pre>

<h3>
<a id="sin-and-cos" class="anchor" href="#sin-and-cos" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sin() and Cos()</h3>

<p>If you're itching to write a function called sin.py or if you really want to figure out a way for a computer with no special functions or libraries to calculate sin(<em>number</em>) then you will want to look into the <a href="http://mathworld.wolfram.com/TaylorSeries.html">Taylor Series</a> of the sin() function. For sin( ) you're going to have something like</p>

<pre><code>sinX = X - X**3/6 + X**5/120 - X**7/5040 + X**9/362880 - X**11/39916800
</code></pre>

<p>with a trick or two to make sure that <em>X</em> is close as possible to zero:</p>

<pre><code>X %= 2*pi
 if X &gt; pi:
        X = -X + pi
 elif X &lt; -pi:
        X = -X - pi
</code></pre>

<p>Note that the further <em>X</em> is from zero, the worse the approximation. Can you think of a way to alter the code to allow <em>X</em> to be even closer to zero ?</p>

<p>For calculating cos(<em>X</em>) without using library functions (<a href="https://github.com/rupertsmall/cs-101/blob/master/cos.py">cos.py</a>) you can use the same Taylor expansion method used for sin(<em>X</em>):</p>

<pre><code>cosX = 1 - X**2/2 + X**4/24 - X**6/720 + X**8/40320 - X**10/3628800
</code></pre>

<p>and again you should find a way to make sure <em>X</em> is as close to zero as possible:</p>

<pre><code>X = abs(float(save))           # take abs() because cos(X) = cos(-X)
X %= 2*pi
if X &gt; pi:                     # in this case cos(X) = cos(2pi - X)
        X = 2*pi - X
</code></pre>

<p>Can you improve on the accuracy of the approximations by altering the code to bound <em>X</em> by an even smaller number?</p>

<p>(TBC. Work In Progress)</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/rupertsmall/cs-101">CS-101</a> is maintained by <a href="https://github.com/rupertsmall">rupertsmall</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>

